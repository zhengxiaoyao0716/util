// The following directive is necessary to make the package coherent:

// +build ignore

// This program generates easyjson_impl.go, value_of.go, value_at.go.
// It can be invoked by running go generate.
package main

// package easyjson

import (
	"bytes"
	"log"
	"os"
	"text/template"
	"time"
)

func main() {
	var implJSON, valueOf, valueAt bytes.Buffer
	for _, data := range []map[string]interface{}{
		{
			"name":    "Object",
			"allows":  []string{"map[string]interface{}"},
			"default": "nil",
		},
		{
			"name":    "Array",
			"allows":  []string{"[]interface{}"},
			"default": "nil",
		},
		{
			"name":    "String",
			"allows":  []string{"string"},
			"default": "\"\"",
		},
		{
			"name":    "Boolean",
			"allows":  []string{"bool"},
			"default": "false",
		},
		{
			"name":    "Number",
			"allows":  []string{"float64", "int"},
			"default": "0",
		},
	} {
		implJSONTemplate.Execute(&implJSON, data)
		valueOfTemplate.Execute(&valueOf, data)
		valueAtTemplate.Execute(&valueAt, map[string]interface{}{"self": "Object", "at": "string", "data": data})
		valueAtTemplate.Execute(&valueAt, map[string]interface{}{"self": "Array", "at": "int", "data": data})
	}

	generate("easyjson_impl.go", "\nimport \"encoding/json\"\n"+implJSON.String())
	generate("value_of.go", valueOf.String())
	generate("value_at.go", valueAt.String())
}

var now = time.Now()

func generate(path, body string) {
	f, err := os.Create(path)
	if err != nil {
		log.Fatalln(err)
	}
	defer f.Close()
	packageTemplate.Execute(f, map[string]interface{}{"time": now, "body": body})
}

var packageTemplate = template.Must(template.New("").Parse(`// Code generated by go generate; DO NOT EDIT.
// This file was generated by robots at
// {{ .time }}
package easyjson
{{ .body }}`))

var implJSONTemplate = template.Must(template.New("").Parse(`
// {{ .name }} implement JSON

func (v {{ .name }}) String() string { return v.JSONString() }
func (v {{ .name }}) JSONString() string {
	bytes, err := json.Marshal(v)
	if err != nil {
		panic(err)
	}
	return string(bytes)
}
`))

var valueOfTemplate = template.Must(template.New("").Parse(`
// {{ .name }}Of translate the interface to {{ .name }}.
func {{ .name }}Of(value interface{}) ({{ .name }}, error) {
	switch value.(type) {
	case {{ .name }}:
		return {{ $.name }}(value.({{ .name }})), nil
	{{ range $_, $allow := .allows }}case {{ $allow }}:
		return {{ $.name }}(value.({{ $allow }})), nil
	{{ end }}default:
		return {{ .default }}, &TypeNotMatchError{value, "{{ .name }}"}
	}
}
func Must{{ .name }}Of(value interface{}) {{ .name }} {
	r, err := {{ .name }}Of(value)
	if err != nil {
		panic(err)
	}
	return r
}
`))

var valueAtTemplate = template.Must(template.New("").Parse(`
// {{ .data.name }}At .
func (json *{{ .self }}) {{ .data.name }}At(at {{ .at }}, defaults ...interface{}) ({{ .data.name }}, error) {
	v, err := json.ValueAt(at, defaults...)
	if err != nil {
		return {{ .data.default }}, err
	}
	r, err := {{ .data.name }}Of(v)
	if err != nil {
		return {{ .data.default }}, &ValueTypeNotMatchError{refContainer{json}, at, err.(*TypeNotMatchError)}
	}
	return r, nil
}
func (json *{{ .self }}) Must{{ .data.name }}At(at {{ .at }}, defaults ...interface{}) {{ .data.name }} {
	r, err := json.{{ .data.name }}At(at, defaults...)
	if err != nil {
		panic(err)
	}
	return r
}
`))
